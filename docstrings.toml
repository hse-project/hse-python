# Docstrings for the hse module

# Be sure to double escape \n. May have unintended effects otherwise.

[hse.version.STRING]
__doc__ = """
A string representing the HSE libary version
"""

[hse.init]
__doc__ = """
Initialize the HSE subsystem

This function initializes a range of different internal HSE structures. It must be
called before any other HSE functions are used. It is not thread safe and is
idempotent.

Args:

`params` - key=value parameters
"""

[hse.fini]
__doc__ = """
Shutdown the HSE subsystem

This function cleanly finalizes a range of different internal HSE structures. It
should be called prior to application exit and is not thread safe. After it is
invoked (and even before it returns), calling any other HSE functions will result in
undefined behavior. This function is not thread safe.
"""

[hse.HseException]
__doc__ = """
Raised when HSE encounters an error. Wrapper around `hse_err_t`.

Members:

`returncode` - Error code returned by HSE
"""

[hse.Kvdb.close]
__doc__ = """
Close an open HSE KVDB

No client thread may enter the HSE KVDB API with the referenced KVDB after this
function starts. This function is not thread safe.
"""

[hse.Kvdb.create]
__doc__ = """
Create a new KVDB instance

This function is not thread safe.

Args:

`home` - KVDB home directory\\n
`params` - key=value parameters
"""

[hse.Kvdb.drop]
__doc__ = """
Remove a KVDB

It is an error to call this function on a KVDB that is open. This function is
not thread safe.

Args:

`home` - KVDB home directory
"""

[hse.Kvdb.open]
__doc__ = """
Open an HSE KVDB for use by the application

The KVDB must already exist and the client must have permission to use it. This
function is not thread safe.

Args:

`home` - KVDB home directory\\n
`params` - key=value parameters
"""

[hse.Kvdb.kvs_names]
__doc__ = """
Get the names of the KVSs within the given KVDB

Key-value stores (KVSs) are opened by name. This function allocates a list of
strings, each containing the name of a KVS. This function is thread safe.
"""

[hse.Kvdb.kvs_create]
__doc__ = """
Create a new KVS within the referenced KVDB

If the KVS will store multi-segment keys then the parameter `pfx_len` should be set
to the desired key prefix length - see `hse.Params.set()` and related functions
below. Otherwise the param should be set to 0 (the default).  An error will result
if there is already a KVS with the given name.  This function is not thread safe.

Args:

`name` - KVS name
`params` - key=value parameters
"""

[hse.Kvdb.kvs_drop]
__doc__ = """
Remove a KVS from the referenced KVDB

It is an error to call this function on a KVS that is open. This function is not
thread safe.

Args:

`name` - KVS name
"""

[hse.Kvdb.kvs_open]
__doc__ = """
Open a KVS in a KVDB

This function is not thread safe.

Args:

`name` - KVS name\\n
`params` - key=value parameters
"""

[hse.Kvdb.sync]
__doc__ = """
Sync data in all of the referenced KVDB's KVSs to stable media and return

Args:

`flags` - Flags for operation specialization
"""

[hse.Kvdb.compact]
__doc__ = """
Request a data compaction operation

In managing the data within an HSE KVDB, there are maintenance activities that occur
as background processing. The application may be aware that it is advantageous to do
enough maintenance now for the database to be as compact as it ever would be in
normal operation. To achieve this, the client calls this function in the following
fashion::

    kvdb.compact(samp_lwm=True)

To cancel an ongoing compaction request for a KVDB::

    kvdb.compact(cancel=True)

See the property `kvdb.compact_status`. This function is thread safe.

Args:

`cancel` - To cancel an ongoing compaction request for a KVDB\\n
`samp_lwm` - To perform compaction to its fullest extent
"""

[hse.Kvdb.compact_status]
__doc__ = """
Get status of an ongoing compaction activity

The caller can examine the properties of the `KvdbCompactStatus` class to determine
the current state of maintenance compaction. This function is thread safe.
"""

[hse.Kvdb.storage_info]
__doc__ = """
Get storage statistics

Obtain allocated and used space for a specified KVDB. This function is thread
safe.
"""

[hse.Kvdb.storage_add]
__doc__ = """
Add a new media class storage to an existing offline KVDB

This function is not thread safe.

Args:

`kvdb_home` - KVDB home directory\\n
`params` - key=value parameters
"""

[hse.Kvdb.transaction]
__doc__ = """
Allocate transaction object

This object can and should be re-used many times to avoid the overhead of
allocation. This function is thread safe.
"""

[hse.Kvs.close]
__doc__ = """
Close an open KVS

No client thread may enter the HSE KVDB API with the referenced KVS after this
function starts. This function is not thread safe.
"""

[hse.Kvs.put]
__doc__ = """
Put a KV pair into KVS

If the key already exists in the KVS then the value is effectively overwritten. The
key length must be in the range [1, `limits.KVS_KEY_LEN_MAX`] while the value length must be
in the range [0, `limits.KVS_VALUE_LEN_MAX`]. See the section on transactions for information
on how puts within transactions are handled. This function is thread safe.

The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this
results in very short sleep's being inserted into the put path. For some kinds of
data (e.g., control metadata) the client may wish to not experience that delay. For
relatively low data rate uses, the caller can set the priority parameter
for an `hse.Kvs.put()` call. Care should be taken when doing so to ensure that the
system does not become overrun. As a rough approximation, doing 1M priority puts per
second marked as PRIORITY is likely an issue. On the other hand, doing 1K small puts
per second marked as PRIORITY is almost certainly fine.

Args:

`key` - Key to put into KVS\\n
`value` - Value associated with key\\n
`txn` - Transaction context\\n
`flags` - Flags for operation specialization
"""

[hse.Kvs.get]
__doc__ = """
Retrieve the value for a given key from KVS

If the key exists in the KVS then the return value is not None. See the section
on transactions for information on how gets within transactions are handled. This
function is thread safe.

Args:

`key` - Key to get from KVS\\n
`txn` - Transaction context\\n
`buf` - Buffer to store the value in, defaults to `hse.KVS_VALUE_LEN_MAX`
"""

[hse.Kvs.delete]
__doc__ = """
Delete the key and its associated value from KVS

It is not an error if the key does not exist within the KVS. See the section on
transactions for information on how deletes within transactions are handled. This
function is thread safe.

Args:

`key` - Key to be deleted from KVS\\n
`priority` - Operation won't be throttled\\n
`txn` - Transaction context
"""

[hse.Kvs.prefix_delete]
__doc__ = """
Delete all KV pairs matching the key prefix from a KVS storing multi-segment keys

This interface is used to delete an entire range of multi-segment keys. To do this
the caller passes a filter with a length equal to the KVS's key prefix length. It is
not an error if no keys exist matching the filter. If there is a filtered iteration
in progress, then that iteration can fail if `hse.Kvs.prefix_delete()` is called with
a filter matching the iteration. This function is thread safe.

If `hse.Kvs.prefix_delete()` is called from a transaction context, it affects no
key-value mutations that are part of the same transaction. Stated differently, for
KVS commands issued within a transaction, all calls to `hse.Kvs.prefix_delete()` are
treated as though they were issued serially at the beginning of the transaction
regardless of the actual order these commands appeared in.

Args:

`filt` - Filter for keys to delete\\n
`priority` - Operation won't be throttled\\n
`txn` - Transaction context
"""

[hse.Kvs.cursor]
__doc__ = """
Creates a cursor used to iterate over a KVS

When cursors are created they are by default forward iterating. If the caller of
hse.Kvs.cursor() passes a reference to an initialized opspec with the
reverse paramater set, then a backwards (reverse sort order) iterating cursor
is created. A cursor's direction is determined when it is created and is immutable.

Cursors are of one of three types: (1) free, (2) transaction snapshot, and (3)
transaction bound. A cursor of type (1) is based on an ephemeral snapshot view of the
KVS at the time it is created. New data is not visible to the cursor until
`hse.KvsCursor.update()` is called on it. A cursor of type (2) takes on the
transaction's ephemeral snapshot but cannot see any of the mutations made by its
associated transaction. A cursor of type (3) is like type (2) but it always can see
the mutations made by the transaction. Calling `hse.KvsCursor.update()` on a cursor of
types (2) and (3) without changing the parameter fields is a no-op. This
function is thread safe.

The cursor parameters shape the type and behavior of the cursor created. The
parameters within cursor functions are independent.

    - To create a cursor of type (1):
        - Pass no optional arguments

    - To create a cursor of type (2):
        - Pass a transaction to the cursor

    - To create a cursor of type (3):
        - Pass a transaction to the cursor with `bind_txn` set

The primary utility of the prefix filter mechanism is to maximize the efficiency of
cursor iteration on a KVS with multi-segment keys. For that use case, the caller
should supply a filter whose length is greater than or equal to the KVS key prefix
length. The caller can also provide a filter that is shorter than the key prefix
length or can perform this operation on a KVS whose key prefix length is zero. In all
cases, the cursor will be restricted to keys matching the given prefix filter.

When a transaction associated with a cursor of type (3) commits or aborts, the state
of the cursor becomes unbound, i.e., it becomes of type (1). What can be seen through
the cursor depends on whether it was created with the `static_view` parameter set.

If it was set, then the cursor retains the snapshot view of the transaction (for both
commit and abort). If it was not set then the view of the cursor is that of the
database at the time of the commit or abort. In the commit case, the cursor can see
the mutations of the transaction, if any. Note that this will make any other
mutations that occurred during the lifespan of the transaction visible as well.

Args:

`filt` - Iteration limited to keys matching this prefix filter\\n
`txn` - Transaction context\\n
`flags` - Flags for operation specialization
"""

[hse.KvdbTransactionState]
__doc__ = """
State a transaction could be in
"""

[hse.KvdbTransaction]
__doc__ = """
The HSE KVDB provides transactions with operations spanning KVSs within a single
KVDB. These transactions have snapshot isolation (a specific form of MVCC) with the
normal semantics (see "Concurrency Control and Recovery in Database Systems" by PA
Bernstein).

One unusual aspect of the API as it relates to transactions is that the data object
that is used to hold client-level transaction state is allocated separately from the
transaction being initiated. As a result, the same object handle should be reused
again and again.

In addition, there is very limited coupling between threading and transactions. A
single thread may have many transactions in flight simultaneously. Also operations
within a transaction can be performed by multiple threads. The latter mode of
operation must currently restrict calls so that only one thread is actively
performing an operation in the context of a particular transaction at any particular
time.

The general lifecycle of a transaction is as follows:

                      +----------+
                      | INVALID  |
                      +----------+
                            |
                            v
                      +----------+
    +---------------->|  ACTIVE  |<----------------+
    |                 +----------+                 |
    |  +-----------+    |      |     +----------+  |
    +--| COMMITTED |<---+      +---->| ABORTED  |--+
       +-----------+                 +----------+

When a transaction is initially allocated, it starts in the INVALID state. When
`hse.KvdbTransaction.begin()` is called with transaction in the INVALID, COMMITTED, or ABORTED
states, it moves to the ACTIVE state. It is an error to call the `hse.KvdbTransaction.begin()`
function on a transaction in the ACTIVE state. For a transaction in the ACTIVE state,
only the functions `hse.KvdbTransaction.commit()` or `hse.KvdbTransaction.abort()` may be called (with the
last doing an abort prior to the free).

When a transaction becomes ACTIVE, it establishes an ephemeral snapshot view of the
state of the KVDB. Any data mutations outside of the transaction's context after that
point are not visible to the transaction. Similarly, any mutations performed within
the context of the transaction are not visible outside of the transaction unless and
until it is committed. All such mutations become visible atomically.
"""

[hse.KvdbTransaction.begin]
__doc__ = """
Initiate transaction

The call fails if the transaction handle refers to an ACTIVE transaction. This
function is thread safe with different transactions.
"""

[hse.KvdbTransaction.commit]
__doc__ = """
Commit all the mutations of the referenced transaction

The call fails if the referenced transaction is not in the ACTIVE state. This
function is thread safe with different transactions.
"""

[hse.KvdbTransaction.abort]
__doc__ = """
Abort/rollback transaction

The call fails if the referenced transaction is not in the ACTIVE state. This
function is thread safe with different transactions.
"""

[hse.KvdbTransaction.state]
__doc__ = """
Retrieve the state of the referenced transaction

This function is thread safe with different transactions.
"""

[hse.KvsCursor.destroy]
__doc__ = """
Destroy cursor

This function is thread safe.
"""

[hse.KvsCursor.items]
__doc__ = """
Convenience function to return an iterator over key/values in a cursor's view

Args:

`max_count` - Limit for the number of results
"""

[hse.KvsCursor.update]
__doc__ = """
Update a plain cursor or modify any cursor

This operation serves to either move the snapshot view forward for a type (1) cursor,
or to transition between being a type (1), type (2), and type (3) cursor.  That
includes toggling the state of the `static_view` parameter.  For example,
to "un-bind" a cursor from a transaction the caller may either set the `txn` parameter
to `None` or clear the `bind_txn` parameter. This function is thread safe
across disparate cursors.

Args:

`txn` - Transaction context
`flags` - Flags for operation specialization
"""

[hse.KvsCursor.seek]
__doc__ = """
Move the cursor to point at the key/value pair at or closest to `key`

The next `hse.KvsCursor.read()` will start at this point. This function is
thread safe across disparate cursors.

Args:

`key` - Key to find
"""

[hse.KvsCursor.seek_range]
__doc__ = """
Move the cursor to the closest match to key, gated by the given filter

Keys read from this cursor will belong to the closed interval defined by the given
filter: [`filt_min`, `filt_max`]. For KVSs storing multi-segment keys, performance
will be enhanced when the length of `filt_min` and `filt_max` are greater than or equal to
the KVS key prefix length. This function is thread safe across disparate cursors.

Note: this is only supported for forward cursors.

Args:

`filt_min` - Filter minimum\\n
`filt_max` - Filter maximum
"""

[hse.KvsCursor.read]
__doc__ = """
Iteratively access the elements pointed to by the cursor

Read a KV pair from the cursor, advancing the cursor past its current location. If
the cursor is at EOF, attempts to read from it will not change the state of the
cursor. The returned key and value will be `None` in the event that the cursor is
at EOF. This function is thread safe across disparate cursors.
"""

[hse.KvsCursor.eof]
__doc__ = """
Flag for determining if the cursor has more data to read
"""

[hse.KvdbCompactStatus]
__doc__ = """
Contains infomation about the Kvdb's current compaction status including
`samp_lwm`, `samp_hwm`, `samp_curr`, `samp_active`, and `canceled`.
"""

[hse.KvdbCompactStatus.samp_lwm]
__doc__ = """
space amp low water mark (%)
"""

[hse.KvdbCompactStatus.samp_hwm]
__doc__ = """
space amp high water mark (%)
"""

[hse.KvdbCompactStatus.samp_curr]
__doc__ = """
current space amp (%)
"""

[hse.KvdbCompactStatus.active]
__doc__ = """
is an externally requested compaction underway
"""

[hse.KvdbCompactStatus.canceled]
__doc__ = """
was an externally requested compaction canceled
"""

[hse.KvdbStorageInfo]
__doc__ = """
Storage information for a KVDB
"""

[hse.KvdbStorageInfo.total_bytes]
__doc__ = """
total space in the file-system containing this kvdb
"""

[hse.KvdbStorageInfo.available_bytes]
__doc__ = """
available space in the file-system containing this kvdb
"""

[hse.KvdbStorageInfo.allocated_bytes]
__doc__ = """
allocated storage space for a kvdb
"""

[hse.KvdbStorageInfo.used_bytes]
__doc__ = """
used storage space for a kvdb
"""

[limits]
__doc__ = """
Global Limits
"""

[limits.KVS_COUNT_MAX]
__doc__ = """
Maximum number of KVS's contained within one KVDB
"""

[limits.KVS_KEY_LEN_MAX]
__doc__ = """
A common requirement for key length for the software above HSE KVDB is 1024.
Combined with a discriminant and (potentially) a chunk key, this pushes us to
1030 bytes keys. Looking at the packing for the on-media format for data, we
can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes
for other data, and we can have 3 keys of 1344 bytes.
"""

[limits.KVS_VALUE_LEN_MAX]
__doc__ = """
Max value length is 1MiB
"""

[limits.KVS_PFX_LEN_MAX]
__doc__ = """
Max key prefix length
"""

[limits.KVS_NAME_LEN_MAX]
__doc__ = """
Max KVS name lengths
"""

[hse.KvsPfxProbeCnt]
__doc__ = """
Enum representing how many results were found in the probe operation.
"""

[hse.prefix_probe]
__doc__ = """
Probe for prefix

Outputs how many matches were encountered - zero, one or multiple.

Args:

`kvs` - Kvs instance\\n
`pfx` - Prefix to be probed\\n
`key_buf` - Buffer which will be populated with contents of first seen key\\n
`val_buf` - Buffer which will be populated with value for `key_buf`\\n
`txn` - Transaction context
"""
